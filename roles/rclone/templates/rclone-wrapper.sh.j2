#!/bin/bash

# ----------------------
# Rclone Wrapper Script
# ----------------------

# Usage: rclone-wrapper.sh [remote_name] [mode] [--dry-run]
#   [remote_name] is the rclone remote
#   [mode] (optional) can be "sync" or "copy"
#   [--dry-run] (optional) makes rclone do a trial run with no changes
#
# If no [mode] is given, the script runs "sync" on the 1st of the month,
# otherwise it defaults to "copy".

# Defaults
REMOTE_NAME=""
RCLONE_MODE=""
RCLONE_DRY_RUN_ENABLED=false
RCLONE_DRY_RUN=""
LOGFILE="/tmp/rclone_wrapper_$(date '+%Y-%m-%d').log"
HC_URL="{{ rclone_hc_url }}{{ rclone_hc_uuid }}/rclone"
FAIL_URL_SUFFIX="/fail"
START_URL_SUFFIX="/start"

# Function to log the outputs with a timestamp
log_output() {
  local msg="$(date '+%Y-%m-%d %H:%M:%S') - $1"
  echo "$msg" | tee -a "$LOGFILE"
}

# local paths for each rclone remote
declare -A LOCAL_PATHS=(
{% for remote in rclone_remotes %}
    ["{{ remote.subpath }}"]="{{ remote.local_path }}"
{% endfor %}
)

# Parse args
for arg in "$@"; do
    case "$arg" in
        --dry-run)
            RCLONE_DRY_RUN_ENABLED=true
            RCLONE_DRY_RUN="--dry-run"
            ;;
        sync|copy)
            RCLONE_MODE="$arg"
            ;;
        *)
            # If it's not a known mode or flag, treat it as the remote name
            if [ -z "$REMOTE_NAME" ]; then
                REMOTE_NAME="$arg"
            fi
            ;;
    esac
done
# Validate input
if [ -z "$REMOTE_NAME" ]; then
    log_output "Usage: $0 [remote_name] [mode] [--dry-run]"
    exit 1
fi

# Lookup local path based on remote name
LOCAL_PATH="${LOCAL_PATHS[$REMOTE_NAME]}"
if [ -z "$LOCAL_PATH" ]; then
    log_output "Unknown remote name: $REMOTE_NAME"
    exit 1
fi

# Decide mode: explicit arg > date logic
if [ -n "$RCLONE_MODE" ]; then
    log_output "Using explicit mode: $RCLONE_MODE"
else
    if [ "$(date '+%d')" -eq 1 ]; then
        RCLONE_MODE="sync"
    else
        RCLONE_MODE="copy"
    fi
    log_output "Using default mode based on date: $RCLONE_MODE"
fi

# Build healthcheck URLs
HC_REMOTE_URL="${HC_URL}-${REMOTE_NAME}"
FAIL_URL="${HC_REMOTE_URL}${FAIL_URL_SUFFIX}"
START_URL="${HC_REMOTE_URL}${START_URL_SUFFIX}"

log_output "Starting rclone $RCLONE_MODE for remote: $REMOTE_NAME"

# ----------------------
# Healthchecks start ping
# ----------------------
if [ "$RCLONE_DRY_RUN_ENABLED" = false ]; then
    curl -fsS --retry 3 "${START_URL}" || {
        log_output "Failed to send start ping to healthcheck URL."
        exit 1
    }
fi

# ----------------------
# Run rclone
# ----------------------
OUTPUT=$(rclone "$RCLONE_MODE" "$LOCAL_PATH" "${REMOTE_NAME}": \
    --config="{{ rclone_config_path }}" \
    --size-only \
    --fast-list \
    --s3-no-check-bucket \
    --s3-chunk-size=64M \
    --s3-upload-concurrency=4 \
    --checkers=8 \
    --transfers=4 \
    --use-mmap \
    --log-level=INFO \
    "$RCLONE_DRY_RUN" 2>&1)

log_output "$OUTPUT"

# Capture the exit status of the rclone command
RC=$?

# ----------------------
# Healthchecks finish ping
# ----------------------
if [ "$RCLONE_DRY_RUN_ENABLED" = false ]; then
    if [ $RC -eq 0 ]; then
        curl -fsS --retry 3 --data-raw "$(tail -n 100 <<< "$OUTPUT")" "${HC_REMOTE_URL}"
        log_output "Rclone ${RCLONE_MODE} completed successfully for $REMOTE_NAME."
    else
        curl -fsS --retry 3 --data-raw "$(tail -n 100 <<< "$OUTPUT")" "$FAIL_URL"
        log_output "Rclone ${RCLONE_MODE} failed for $REMOTE_NAME."
    fi
else
    log_output "Dry run completed for $REMOTE_NAME. No healthcheck ping sent."
fi
